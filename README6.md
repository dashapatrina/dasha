

 # Вариант 20. Имитация отжига для задачи размещения центров
### Задача:
реализовать генетический алгоритм для решения задачи коммивояжера.

### Требования: 
- Представление: перестановка городов 
- Кроссовер: Order Crossover (OX)
- Мутация: случайный swap двух городов 
- Размер популяции: 30 - Количество поколений: 100 
- Вывести лучший найденный маршрут и его стоимость 

### Входные данные: 
Матрица расстояний для 10 городов

### Объяснение работы алгоритма:

Шаг 1: Определение функций оценки и преобразований
Функция оценки маршрута (evaluate_route): Вычисляет суммарное расстояние маршрута. Для последнего сегмента соединяется последний город с первым городом. Используется цикл для подсчета расстояния по каждому сегменту.
def evaluate_route(route, distance_matrix):    ...
Операция кроссовера (Order Crossover): Используется оператор Order Crossover (OX). Из родительских хромосом копируются сегменты определённой длины, оставшаяся часть заполняется элементами другого родителя в исходном порядке появления.
def crossover(parent1, parent2):    ...

Операция мутации: Произвольный обмен двух элементов маршрута ("swap"). Применяется с небольшой вероятностью.
def mutate(route):    ...

Шаг 2: Инициализация популяции
Популяция представляет собой набор маршрутов. Каждый маршрут — это последовательность индексов городов. Начальная популяция генерируется случайным образом.

```python
population = [random.sample(range(num_cities), num_cities) for _ in range(population_size)]
```

Шаг 3: Оценка приспособленности (fitness evaluation)
Каждый маршрут оценивается функцией оценки (evaluate_route), результатом которой является общая протяженность маршрута. Чем меньше эта величина, тем лучше индивидуум.

Шаг 4: Выбор родителей
Родители выбираются среди лучшей половины популяции текущего поколения (элитизм).

Шаг 5: Создание нового поколения
Новое поколение формируется методом Order Crossover и мутаций. Родители выбирают случайным образом, дети создаются путем пересечения. После кроссинга некоторые индивиды подвергаются мутации с малой вероятностью.

Шаг 6: Итерации и сохранение наилучшего результата
Процесс продолжается заданное число поколений. Лучший маршрут сохраняется отдельно вне зависимости от изменений поколений.

### Временная сложность алгоритма:
Инициализация популяции: 
O(N^2)
N — размер популяции.
Оценка каждого маршрута: 
O(L)
L — количество городов. Всего оценок порядка O(NP).
Выбор родителей: 
O(P log P), сортировка по результатам оценки.
Формирование новых особей: 
O(LP) операций для кроссовера и мутации.
Общее выполнение: каждая итерация занимает примерно O(PL). Полное выполнение за G поколений даёт общую сложность O(GPL).

Таким образом, полная временная сложность всего алгоритма равна:
O(G⋅N⋅L)


# Контрольный вопрос 20

### Примеры практических применений эвристических и приближенных алгоритмов на Python:

```python
# 1. Задача оптимизации маршрута доставки товаров (алгоритмы типа Traveling Salesman Problem)
from tsp_solver.greedy import solve_tsp

distances = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]
path = solve_tsp(distances)
print("Оптимальный путь:", path)

# 2. Оптимизация расписания занятий (алгоритмы назначения ресурсов)
courses = ["Math", "Physics", "Chemistry"]
timeslots = ["Morning", "Afternoon", "Evening"]
assignments = {"Math": "Morning", "Physics": "Afternoon", "Chemistry": "Evening"}

# 3. Планирование производственных процессов (алгоритмы планирования производства)
jobs = ["JobA", "JobB", "JobC"]
machines = ["Machine1", "Machine2"]
schedule = {job: machine for job, machine in zip(jobs, machines)}

# 4. Распределение трафика сети (алгоритмы балансировки нагрузки)
network_nodes = ["Node1", "Node2", "Node3"]
traffic_load = [100, 150, 200]
distribution = dict(zip(network_nodes, traffic_load))

# 5. Поиск ближайших соседей (алгоритмы кластеризации)
from sklearn.cluster import KMeans
data_points = [[1, 2], [1, 4], [1, 0], [10, 2], [10, 4], [10, 0]]
kmeans = KMeans(n_clusters=2).fit(data_points)
labels = kmeans.labels_
```
Эти примеры демонстрируют применение эвристик и приближённых методов в конкретных областях: логистике, образовании, производстве, сетевых технологиях и анализе данных.
