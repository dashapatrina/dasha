[Алгоритмы. Работа в VS Code с алгор.txt](https://github.com/user-attachments/files/23228205/VS.Code.txt)
Алгоритмы. Работа в VS Code с алгоритмами сортировки и поиска

1. Определение:
Сортировка выбора (Selection Sort) — это простой алгоритм сортировки массива элементов путем последовательного выбора минимального элемента среди оставшихся несортированных элементов и помещения его в начало отсортированной части массива.

// Функция quicksort реализует основную логику быстрого сортирования
public class QuickSort {
    
    // Метод sort запускает процесс сортировки всего массива
    public static void sort(int[] array) {
        quickSort(array, 0, array.length - 1); // Передаем весь массив и индексы начала и конца
    }

    // Рекурсивная функция быстрой сортировки
    private static void quickSort(int[] array, int low, int high) {
        if (low >= high) return; // Базовый случай: если индекс начала >= индекса конца, значит подмассив пуст или состоит из одного элемента
        
        // Опорный элемент выбирается случайно, чтобы избежать худшего случая O(n^2)
        int pivotIndex = partition(array, low, high);
        
        // Сортируем левую половину относительно выбранного опорного элемента
        quickSort(array, low, pivotIndex - 1);
        
        // Сортируем правую половину
        quickSort(array, pivotIndex + 1, high);
    }

    // Функция partition размещает опорный элемент на правильную позицию,
    // переставляя остальные элементы вокруг него
    private static int partition(int[] array, int low, int high) {
        // Выбираем последний элемент как опорный
        int pivotValue = array[high];
        
        // Индекс первого элемента большей области
        int i = low - 1;
        
        // Перебираем элементы слева направо
        for (int j = low; j <= high - 1; j++) {
            // Если текущий элемент меньше или равен опорному значению,
            // меняем местами с элементом в левой области
            if (array[j] <= pivotValue) {
                i++;
                swap(array, i, j); // Обмениваем два элемента
            }
        }
        
        // Перемещаем опорный элемент на правильное место
        swap(array, i + 1, high);
        
        // Возвращаем новый индекс опорного элемента
        return i + 1;
    }

    // Вспомогательная функция для обмена двух элементов в массиве
    private static void swap(int[] array, int index1, int index2) {
        int temp = array[index1];     // Сохраняем значение первого элемента
        array[index1] = array[index2]; // Присваиваем первому элементу значение второго
        array[index2] = temp;          // Присваиваем второму элементу сохраненное значение
    }

    // Тестируем работу метода
    public static void main(String[] args) {
        int[] exampleArray = {64, 25, 12, 22, 11};
        System.out.println("Исходный массив:");
        printArray(exampleArray);
        
        sort(exampleArray);           // Запускаем сортировку
        
        System.out.println("\nОтсортированный массив:");
        printArray(exampleArray);     // Выводим отсортированный массив
    }

    // Дополнительный метод для вывода содержимого массива
    private static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
    }
}

Вывод в консоль:
Исходный массив:
64 25 12 22 11 
Отсортированный массив:
11 12 22 25 64


Объяснение работы кода:
1. Выбор опорного элемента: Мы выбрали самый простой способ выбора опорного элемента — это крайний правый элемент текущего подмассива (pivotValue = array[high]). Можно выбирать и другим способом (например, среднее значение или случайный элемент), но это влияет лишь на производительность в особых случаях, а общая логика остаётся той же.
2. Разделение массива: Далее идёт цикл, в ходе которого каждый элемент сравнивается с опорным значением. Все элементы, которые меньше или равны опорному, собираются слева от будущей позиции опорного значения, а большие остаются справа. После завершения цикла опорный элемент ставится на своё финальное место путём обмена с последним "меньшим" элементом (i+1).
3. Рекурсия: Процесс повторяется для обоих получившихся подмассивов (левого и правого), пока длина каждого подмассива не станет равна нулю или единице. Таким образом, рекурсивно выполняется сортировка всего массива.

Временная сложность: Общая временная сложность — O(n log n)
Объяснение временной сложности:Алгоритм QuickSort имеет среднюю временную сложность, поскольку массив рекурсивно делится на примерно равные части. Худшая временная сложность достигает O(N^2), если выбор опорного элемента неудачен и массив плохо сбалансирован.


2. Алгоритм сортировка обменом (пузырьком) (Bubble Sort)
Сортировка пузырьком — алгоритм сортировки, который последовательно проходит по списку элементов, сравнивая соседние элементы и меняя их местами, если они расположены в неправильном порядке. Проход повторяется многократно, пока весь список не станет отсортированным. Каждый проход перемещает наибольший элемент своего участка ближе к концу списка, подобно тому, как пузырек поднимается вверх в воде.

Сортировка обменом (пузырьком) (Bubble Sort) на джава 
import java.util.Arrays;

public class Main {
    // Метод для сортировки массива методом пузырька
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        // Проходим по всем элементам массива
        for (int i = 0; i < n - 1; i++) {
            // Последняя позиция каждого прохода уже на своём месте
            for (int j = 0; j < n - i - 1; j++) {
                // Сравниваем соседние элементы
                if (arr[j] > arr[j + 1]) {
                    // Меняем местами, если они стоят в неправильном порядке
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

    // Основной метод
    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("Исходный массив:");
        System.out.println(Arrays.toString(arr));

        bubbleSort(arr); // Применяем сортировку

        System.out.println("Отсортированный массив:");
        System.out.println(Arrays.toString(arr)); // Выводим отсортированный массив
    }
}

Вывод в консоль:
Исходный массив: 64, 34, 25, 12, 22, 11, 90
Отсортированный массив: 11, 12, 22, 25, 34, 64, 90

Объяснение работы кода: 
- Внешний цикл (`for (int i = 0; i < n - 1; i++)`) проходит по всему массиву, уменьшая область проверки с каждым новым шагом, потому что на каждом полном проходе максимальный элемент гарантированно встаёт на свое правильное место в конце массива.
- Во внутреннем цикле (`for (int j = 0; j < n - i - 1; j++)`) происходит непосредственное сравнение соседних элементов. Если текущий элемент больше следующего, они меняются местами.
- Замена реализуется путём сохранения значения одного элемента во временную переменную (`int temp`), изменения положения обоих элементов и восстановления прежнего значения в новом положении.
- Благодаря такому подходу, большие элементы постепенно перемещаются к концу массива. 

Этот метод эффективен для малых объёмов данных и хорош для демонстрации принципов сортировки, однако для больших массивов применяется редко из-за квадратичной сложности O(N²).


Временная сложность: O(n?)
Объяснение временной сложности: Временная сложность алгоритма сортировки пузырьком составляет O(n^2), так как присутствуют два вложенных цикла: внешний цикл проходит по каждому элементу массива, а внутренний цикл сравнивает и меняет местами соседние элементы.


3.Алгоритм сортировка вставками - это простой алгоритм сортировки, который последовательно проходит по элементам массива, сравнивая каждый новый элемент с предыдущими элементами и помещая его на правильную позицию среди уже отсортированных элементов.

def insertion_sort(arr):
    # Проходим по всем элементам массива, начиная со второго
    for i in range(1, len(arr)):
        key = arr[i]              # Текущий элемент, который нужно вставить
        j = i - 1                 # Индекс предыдущего элемента

        # Перемещаем элементы arr[0..i-1], которые больше key,
        # на одну позицию вперёд
        while j >= 0 and arr[j] > key:
            arr[j+1] = arr[j]
            j -= 1
        
        arr[j+1] = key           # Вставляем key на правильное место


# Функция для печати элементов массива
def print_array(arr):
    for val in arr:
        print(val, end=" ")
    print()

if __name__ == "__main__":
    # Исходный массив
    array = [12, 11, 13, 5, 6]
    
    print("Исходный массив:")
    print_array(array)

    # Сортируем массив методом вставок
    insertion_sort(array)

    print("Отсортированный массив:")
    print_array(array)

Вывод в консоль:
Исходный массив: [12, 11, 13, 5, 6] 
Отсортированный массив: [5, 6, 11, 12, 13]

Объяснение работы кода:Код реализует сортировку вставками для массива `arr`. Алгоритм последовательно проходит по каждому элементу массива, начиная со второго, и вставляет его на правильное место среди ранее отсортированных элементов. Во внешнем цикле (`for i in range(1, len(arr))`) берётся очередной элемент `arr[i]`, обозначаемый переменной `key`. Затем внутренний цикл (`while j >= 0 and arr[j] > key`) сдвигает элементы слева направо, пока не найдёт подходящую позицию для вставки `key`. Это делается путём сравнения значений и последовательного перемещения предыдущих элементов вправо (`arr[j+1] = arr[j]`), постепенно уменьшая индекс `j`. После завершения внутреннего цикла элемент `key` помещается на правильную позицию (`arr[j+1] = key`), обеспечивая порядок среди обработанных элементов.

Временная сложность: O(n²)
Объяснение временной сложности: составляет O(n^2), поскольку внешний цикл выполняется n-1 раз, а внутренний цикл в худшем случае тоже может пройти по всему предыдущему участку массива длиной до n-1. Таким образом, общее количество операций пропорционально квадрату длины массива.

4.Сортировка слиянием (Merge Sort)- это алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно) в определённом порядке.

public class MergeSort {

    public static void main(String[] args) {
        int[] array = {38, 27, 43, 3, 9, 82, 10};
        
        System.out.println("Исходный массив:");
        printArray(array);
        
        sort(array);
        
        System.out.println("\nОтсортированный массив:");
        printArray(array);
    }

    // Основная функция сортировки слиянием
    private static void sort(int[] arr) {
        if (arr.length > 1) {
            // Деление массива на две части
            int mid = arr.length / 2;
            int[] left = new int[mid];
            int[] right = new int[arr.length - mid];
            
            for (int i = 0; i < mid; i++) {
                left[i] = arr[i]; // Левая половина
            }
            
            for (int i = mid; i < arr.length; i++) {
                right[i - mid] = arr[i]; // Правая половина
            }
            
            // Рекурсивно сортируем обе половины
            sort(left); 
            sort(right);
            
            // Слияние отсортированных половинок
            merge(arr, left, right);
        }
    }

    // Процедура слияния двух отсортированных массивов
    private static void merge(int[] arr, int[] left, int[] right) {
        int l = 0;   // Индекс левого массива
        int r = 0;   // Индекс правого массива
        int k = 0;   // Индекс результирующего массива
        
        while (l < left.length && r < right.length) {
            if (left[l] <= right[r]) {
                arr[k++] = left[l++];
            } else {
                arr[k++] = right[r++];
            }
        }
        
        // Добавление оставшихся элементов слева
        while (l < left.length) {
            arr[k++] = left[l++];
        }
        
        // Добавление оставшихся элементов справа
        while (r < right.length) {
            arr[k++] = right[r++];
        }
    }

    // Вспомогательная функция для вывода массива
    private static void printArray(int[] arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}

Вывод в консоль:
Исходный массив:38 27 43 3 9 82 10 
Отсортированный массив:3 9 10 27 38 43 82 

Объяснение работы кода:Алгоритм рекурсивно делит массив на подмассивы, пока их длина не достигнет единицы. Затем отсортированные подмассивы объединяются функцией `merge`. Она выбирает минимальные элементы из подмассивов и формирует единый отсортированный массив.
Временная сложность: O(n log n)
Объяснение временной сложности:Массив делится пополам на каждом уровне рекурсии, следовательно, глубина рекурсии равна log n. На каждом уровне рекурсии функция `merge` обрабатывает все n элементов массива за линейное время O(n). Поскольку существует log n уровней, общая временная сложность составляет O(n log n).

5.Сортировка Шелла (Shell sort) — это алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга.
def shell_sort(arr):
    gap = len(arr) // 2  # Устанавливаем начальный промежуток (gap)
    
    # Продолжаем уменьшать gap, пока он не достигнет нуля
    while gap > 0:
        # Проходим по всему массиву с установленным промежутком
        for i in range(gap, len(arr)):  
            current_value = arr[i]  # Текущий элемент
            position = i            # Его текущая позиция
            
            # Сравниваем текущий элемент с элементами, расположенными на расстоянии gap
            while position >= gap and arr[position-gap] > current_value:
                # Если предшествующий элемент больше, сдвигаем его вперед
                arr[position] = arr[position-gap]
                position -= gap  # Передвигаемся назад на gap позиций
            
            # Когда нашли правильное место, ставим текущий элемент на свою позицию
            arr[position] = current_value
        
        # Уменьшаем gap вдвое для следующей итерации
        gap //= 2
# Пример использования
arr = [64, 34, 25, 12, 22, 11, 90]
shell_sort(arr)
print("Отсортированный массив:", arr)
Вывод в консоль:
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]
Объяснение работы кода: сначала массив делится на группы, каждая группа формируется таким образом, что её элементы находятся на фиксированном расстоянии друг от друга (это расстояние называется "gap"). Затем каждая группа сортируется независимо друг от друга. Постепенно "gap" уменьшается, и на последней стадии происходит обычная сортировка вставками над всем массивом.
Временная сложность: O(n log n)
Объяснение временной сложности: Внешний цикл gap уменьшается вдвое от n/2 до 1, что даёт log?(n) итераций 


6.Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.

#include <iostream>
using namespace std;
// Функция для обмена двух элементов в массиве
void swap(int& a, int& b) {
    int temp = a;   // Сохраняем первое значение во временную переменную
    a = b;          // Первое значение присваиваем второму
    b = temp;       // Второе значение присваиваем первому}
// Процедура разделения массива (Partition)int partition(int arr[], int low, int high) {
    int pivot = arr[high];   // Последний элемент массива выбран в качестве опорного (pivot)
    int i = low - 1;         // Указатель на границу меньшей секции

    // Основной цикл: перебор всех элементов кроме последнего (pivota)
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {  // Если текущий элемент меньше pivota
            i++;              // Увеличить границу меньшей секции
            swap(arr[i], arr[j]);  // Поменять местами текущий элемент с границей
        }
    }

    // Поместить pivot на своё место
    swap(arr[i + 1], arr[high]);
    return i + 1;             // Возвращаем индекс позиции pivot'a}
// Главная рекурсивная функция быстрой сортировки
void quickSort(int arr[], int low, int high) {
    if (low < high) {                 // Базовый случай: если индексы пересеклись, выход
        int pi = partition(arr, low, high);  // Найти индекс опоры (partition index)
        
        // Рекурсивно сортировать левую часть
        quickSort(arr, low, pi - 1);
        
        // Рекурсивно сортировать правую часть
        quickSort(arr, pi + 1, high);
    }}
// Вспомогательная функция для вывода массива
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++)
        cout << arr[i] << " ";
    cout << endl;}
// Основная программаint main() {
    int arr[] = {10, 7, 8, 9, 1, 5};  // Исходный массив
    int n = sizeof(arr) / sizeof(arr[0]);  // Определение размера массива
    
    cout << "Исходный массив: ";
    printArray(arr, n);  // Выводим исходный массив
    
    quickSort(arr, 0, n - 1);  // Вызываем процедуру быстрой сортировки
    
    cout << "Отсортированный массив: ";
    printArray(arr, n);  // Выводим отсортированный массив
    
??return 0;
??}
Вывод в консоль:
Исходный массив: 10 7 8 9 1 5 
Отсортированный массив: 1 5 7 8 9 10 
Объяснение работы кода: Алгоритм рекурсивно выбирает опорный элемент (pivot), разделят массив на меньшие и большие, затем сортирует части. Функция swap - меняет местами два элемента. Функция partition - выбирает опорный элемент (pivot) и перераспределяет элементы так, чтобы: Слева были элементы меньше pivot, Справа - больше или равные pivot. Функция quickSort рекурсивно вызывает partition для разделения массива, сортирует левую и правую части относительно pivot. Процесс повторяется до полной сортировки массива
Временная сложность: O(n log n)
Объяснение временной сложности: В среднем случае массив делится пополам на каждом шаге (log n уровней), и на каждом уровне выполняется O(n) операций


7.Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.

import java.util.Arrays;
class HeapSort {

    // Метод для преобразования двоичного дерева в кучу (heapify)
    public static void heapify(int[] arr, int n, int root) {
        int largest = root;          // Рассматриваемый узел (корень)
        int leftChild = 2 * root + 1;// Левый дочерний узел
        int rightChild = 2 * root + 2;// Правый дочерний узел

        // Если левый ребенок существует и больше корня
        if (leftChild < n && arr[leftChild] > arr[largest])
            largest = leftChild;

        // Если правый ребенок существует и больше самого большого узла
        if (rightChild < n && arr[rightChild] > arr[largest])
            largest = rightChild;

        // Если корень не самый большой, меняем местами и восстанавливаем структуру
        if (largest != root) {
            int temp = arr[root];
            arr[root] = arr[largest];
            arr[largest] = temp;

            // Рекурсивно применяем heapify к новому поддереву
            heapify(arr, n, largest);
        }
    }

    // Основная процедура сортировки кучей
    public static void heapSort(int[] arr) {
        int n = arr.length;

        // Строим max-кучу (перестраиваем дерево в бинарную кучу)
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);

        // Один за другим извлекаем максимальный элемент из кучи
        for (int i = n - 1; i > 0; i--) {
            // Перемещение текущего корневого элемента в конец
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // Вызываем heapify на уменьшенной куче
            heapify(arr, i, 0);
        }
    }

    // Главный метод для тестирования
    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6, 7};
        System.out.println("Исходный массив: " + Arrays.toString(arr));

        heapSort(arr); // Вызываем сортировку

        System.out.println("Отсортированный массив: " + Arrays.toString(arr));
??}
??}
Вывод в консоль:
Исходный массив: [12, 11, 13, 5, 6, 7]
Отсортированный массив: [5, 6, 7, 11, 12, 13]
Объяснение работы кода: Код реализует сортировку кучей (heap sort) на Java для массива arrararr Алгоритм строит max-кучу (где родитель больше детей), затем извлекает максимумы, перемещая их в конец массива.
Временная сложность: O(n log n)
Объяснение временной сложности: выполняется n раз, каждое извлечение требует O(log n) операций для восстановления структуры кучи Итого: O(n) + O(n log n) = O(n log n)
8.Последовательный (линейный) поиск — это простой алгоритм, который поочередно проверяет каждый элемент в наборе данных, пока не будет найден искомый элемент или не будет пройден весь список.
public class LinearSearch {

    // Метод для выполнения линейного поиска
    public static int linearSearch(int[] arr, int target) {
        // Просматриваем каждый элемент массива по порядку
        for (int i = 0; i < arr.length; i++) {
            // Если текущий элемент совпадает с искомым значением
            if (arr[i] == target) {
                return i; // Возвращаем индекс найденного элемента
            }
        }
        return -1; // Если элемент не найден, возвращаем -1
    }

    // Тестовый метод для демонстрации работы поиска
    public static void main(String[] args) {
        int[] data = {3, 7, 1, 9, 5};
        int searchElement = 9;
        
        // Вызываем функцию поиска
        int result = linearSearch(data, searchElement);
        
        // Вывод результата
        if(result != -1) {
            System.out.println("Элемент найден на индексе: " + result);
        } else {
            System.out.println("Элемент не найден");
        }
    }
}
Вывод в консоль:
Элемент найден на индексе: 3
Объяснение работы кода: Цикл for проходит по всем элементам массива последовательно, проверяя каждый элемент на совпадение с искомым значением. Условие if:Если текущий элемент массива совпадает с искомым значением, возвращается индекс этого элемента. Возврат результата:Если элемент найден, возвращает его индекс. Если элемент не найден, возвращает -1. Метод main:Демонстрирует использование метода линейного поиска. Создается массив данных. Осуществляется поиск конкретного элемента
Временная сложность: O(n)
Объяснение временной сложности: Алгоритм последовательно проверяет каждый элемент массива (цикл for от 0 до n-1). Проходит все n элементов, делая n сравнений. Это стандартный анализ линейного поиска.
9.Бинарный поиск (Binary Search) — это алгоритм для поиска элемента в отсортированном массиве.

def binary_search(arr, x):
    """
    Бинарный поиск числа x в отсортированном массиве arr.
    Возвращает индекс числа, если оно найдено, иначе -1.
    """
    low = 0                     # Нижняя граница диапазона поиска
    high = len(arr) - 1         # Верхняя граница диапазона поиска
    
    while low <= high:          # Пока границы не пересеклись
        mid = (low + high) // 2 # Вычисляем средний индекс
        
        # Проверяем, какой участок продолжать искать
        if arr[mid] < x:        # Если средний элемент меньше искомого
            low = mid + 1       # Искать в правом диапазоне
        elif arr[mid] > x:      # Если средний элемент больше искомого
            high = mid - 1      # Искать в левом диапазоне
        else:                   # Средний элемент равен искомому
            return mid          # Возвратим индекс среднего элемента
    
    return -1                   # Если элемент не найден, вернуть -1
# Пример использования
sorted_array = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
search_element = 11

result = binary_search(sorted_array, search_element)
if result != -1:
    print(f"Элемент {search_element} найден на индексе {result}.")else:
    print(f"Элемент {search_element} не найден.")
Вывод в консоль:
Элемент 11 найден на индексе 4
Объяснение работы кода: Алгоритм делит диапазон пополам, сравнивает средний элемент с искомым и сужает поиск. 
Временная сложность: O(log n)
Объяснение временной сложности: Алгоритм на каждом шаге делит диапазон поиска пополам (low и high сужаются), что требует ~log?(n) итераций цикла (для n элементов). Каждая итерация — O(1) (сравнения и арифметика). Итого: O(log n)

10.Интерполирующий поиск  — это алгоритм поиска значения в упорядоченном массиве чисел, который работает быстрее бинарного поиска при равномерном распределении данных.

#include <iostream>
using namespace std;
// Интерполирующий поиск в отсортированном массивеint interpolationSearch(int arr[], int n, int x) {
    int low = 0;              // Нижний индекс
    int high = n - 1;         // Верхний индекс

    // Пока нижний индекс меньше верхнего и искомое значение лежит в пределах крайних элементов
    while ((low <= high) && (x >= arr[low]) && (x <= arr[high])) {
        // Если массив содержит одинаковые элементы, проверить крайние индексы
        if (arr[low] == arr[high]) {
            if (arr[low] == x) return low;
            return -1;
        }

        // Формула интерполяционного поиска
        int pos = low + (((double)(high - low) /
                         (arr[high] - arr[low])) *
                        (x - arr[low]));

        // Проверка трех возможных случаев
        if (arr[pos] == x) {   // Значение найдено
            return pos;
        }
        if (arr[pos] < x) {    // Значение больше, смещаемся вправо
            low = pos + 1;
        } else {               // Значение меньше, смещаемся влево
            high = pos - 1;
        }
    }

    return -1;                // Если элемент не найден}
// Основная программаint main() {
    int sortedArr[] = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47};
    int n = sizeof(sortedArr) / sizeof(sortedArr[0]);
    int elementToFind = 18;

    int index = interpolationSearch(sortedArr, n, elementToFind);

    if (index != -1) {
        cout << "Элемент " << elementToFind << " найден на индексе " << index << "." << endl;
    } else {
        cout << "Элемент " << elementToFind << " не найден." << endl;
    }

??return 0;
??}
Вывод в консоль:
Элемент 18 найден на индексе 4.
Объяснение работы кода: Похож на бинарный поиск, но вместо деления пополам, предполагает позицию элемента на основе его значения и значений на границах, предполагая равномерное распределение.
Временная сложность: O(log log n)
Объяснение временной сложности: Интерполяционный поиск использует формулу для оценки позиции элемента на основе его значения (предполагая равномерное распределение), что делает его быстрее бинарного поиска (O(log n)) в идеальных условиях — диапазон сужается экспоненциально быстрее.

11.Поиск методом Фибоначчи  — это итеративный алгоритм для поиска экстремума (минимума или максимума) унимодальной функции на заданном интервале, а также метод поиска нужного значения в отсортированном массиве.

def fibonacci_search(arr, x):
    """Алгоритм поиска Фибоначчи"""
    # Первые числа ряда Фибоначчи
    fib_m_minus_2 = 0  # F(m-2)
    fib_m_minus_1 = 1  # F(m-1)
    fib_M = fib_m_minus_1 + fib_m_minus_2  # F(m)

    # Ищем минимальное число Фибоначчи, большее или равное длине массива
    while fib_M < len(arr):
        fib_m_minus_2 = fib_m_minus_1
        fib_m_minus_1 = fib_M
        fib_M = fib_m_minus_1 + fib_m_minus_2

    offset = -1  # смещение, показывающее начало отрезка поиска

    # Повторяем, пока отрезок поиска не станет пустым
    while fib_M > 1:
        # Определяем индекс для проверки
        i = min(offset + fib_m_minus_2, len(arr)-1)

        # Три возможных сценария:
        if arr[i] < x:  # Если искомое больше, сужаем область поиска вправо
            fib_M = fib_m_minus_1
            fib_m_minus_1 = fib_m_minus_2
            fib_m_minus_2 = fib_M - fib_m_minus_1
            offset = i
        elif arr[i] > x:  # Если искомое меньше, сужаем область поиска влево
            fib_M = fib_m_minus_2
            fib_m_minus_1 = fib_m_minus_1 - fib_m_minus_2
            fib_m_minus_2 = fib_M - fib_m_minus_1
        else:  # Совпадение, элемент найден
            return i

    # Если остался единственный элемент для проверки
    if fib_m_minus_1 and arr[offset+1] == x:
        return offset + 1

    # Если ничего не найдено
    return -1
# Тестируем функцию
data = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
element_to_find = 85

index = fibonacci_search(data, element_to_find)
if index != -1:
    print(f"Элемент {element_to_find} найден на индексе {index}")else:
    print(f"Элемент {element_to_find} не найден")
Вывод в консоль:
Элемент 85 найден на индексе 8
Объяснение работы кода: Использует числа Фибоначчи для определения точек разбиения массива, аналогично бинарному поиску (деление на части), но с разными пропорциями.
Временная сложность: O(log n)
Объяснение временной сложности: Количество чисел Фибоначчи до n примерно равно log n. Каждая итерация цикла while уменьшает размер области поиска, используя меньшие числа Фибоначчи, что приводит к O(log n) итераций.










КОНТРОЛЬНАЯ РАБОТА

1. Блочная (или корзинная) сортировка (Bucket Sort) — это метод сортировки, при котором элементы исходного массива распределяются по различным контейнерам («корзинам»), каждая из которых потом индивидуально сортируется и объединяется в общий отсортированный список.



Объяснения работы кода:
1.Определяется количество корзин (например, по диапазону значений элементов):

min_val = min(arr)
max_val = max(arr)
num_buckets = len(arr)
buckets = [[] for _ in range(num_buckets)]
Минимальное и максимальное значения используются для равномерного распределения элементов по корзинам. Число корзин принимается равным длине массива.

2.Каждый элемент помещается в корзину согласно функции распределения:
for val in arr:
    index = int((val - min_val) / (max_val - min_val + 1) * (num_buckets - 1))
    buckets[index].append(val)
Каждое значение сопоставляется определённой корзине на основании формулы распределения. Эта формула равномерно распределяет элементы по корзинам исходя из их относительного положения в диапазоне значений.

3.Содержимое каждой корзины сортируется индивидуально:
sorted_arr = []
for bucket in buckets:
    sorted_bucket = sorted(bucket)
    sorted_arr.extend(sorted_bucket)
Индивидуально каждая корзина сортируется встроенной функцией сортировки Python. Так как распределение элементов достаточно однородно, эта процедура быстрая и эффективная.

4.Корзины соединяются в порядке увеличения диапазона:
Последовательное объединение отсортированных корзин формирует окончательно отсортированный массив.

Таким образом, алгоритм сначала разделяет элементы на группы, а затем быстро собирает их вместе, позволяя эффективно сортировать даже большие наборы данных.

Оценка временной сложности: O(N + k), где N — длина исходного массива, а k — количество корзин. Если распределение достаточно равномерное, то средняя сложность приближается к линейному порядку.
Объяснение временной сложности: Основная идея заключается в распределении элементов по различным контейнерам («корзинам»), что снижает нагрузку на общую операцию сортировки, особенно если элементам удается разделить массив на небольшие части с близкими значениями.

2. Блинная Сортировка
Определение: Идея состоит в том, чтобы каждый раз находить самый большой несортированный элемент и перевернуть его вверх стопки, а затем перевернуть всю верхнюю часть стопки таким образом, чтобы этот элемент оказался внизу.


Объяснение работы: 
1. Найти максимальный элемент в неотсортированной части массива.
max_idx = arr.index(max(arr[:curr_size]))
Максимальный элемент определяется путём нахождения индекса максимального значения в ещё не отсортированном фрагменте массива (arr[:curr_size]).

2.Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот элемент оказался первым.
flip(arr, max_idx)
Подмассив переворачивается с помощью вспомогательной функции flip(), перемещая максимальный элемент на первое место в текущем несортированном участке.

3.Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце.
flip(arr, curr_size - 1)
Весь текущий участок массива (до последнего неотсортированного элемента) переворачивается второй раз, отправляя максимальный элемент в конец массива.

4.Повторить процесс для оставшейся неотсортированной части массива.
curr_size -= 1
Размер обрабатываемой части уменьшается на единицу, и шаги повторяются заново, пока вся остальная часть массива не окажется отсортирована.

временная сложность: О(N²) 
Краткое объяснение: каждая итерация требует нахождения максимального элемента и двух операций переворота, каждая из которых выполняется за линейное время относительно размера текущего слоя.

3.Сортировка бусинами (Гравитационная)

Определение: Гравитационная сортировка — это визуализированный способ сортировки чисел, имитирующий гравитационное воздействие на бусы, подвешенные вертикально на нитях разной длины. Суть метода в том, что короткие нити будут подниматься быстрее длинных, что обеспечивает упорядочение.

​
Объяснение работы кода:
1. Каждый элемент массива представляется в виде горизонтального ряда бусин, количество которых соответствует его значению.
rows = [[True]*num + [False]*(max(arr)-num) for num in arr]
Здесь каждому числу из исходного массива присваиваются "бусины" (представленные как `True`), количество которых равно самому числу, а остальные места заполнены пустотой (`False`).

2. Бусины располагаются на «стержнях».
transposed = list(map(list, zip(*rows)))
Матрица поворачивается на бок, создавая представление вертикальных стержней (столбцов), на которых расположены бусины.

3. Под действием «гравитации» бусины падают вниз.
columns_sorted = [[any(row) for row in col] for col in transposed]
Каждая колонка проверяется на наличие хотя бы одной `True` («бусины») сверху вниз. Это аналогично тому, как бусины сползают вниз под действием силы тяжести.

4. После оседания бусин строки считываются сверху вниз — получается отсортированный массив.
sorted_rows = list(map(list, zip(*columns_sorted)))
return [sum(row) for row in sorted_rows]
Строки возвращаются обратно в правильное положение, и подсчитывается количество `True` в каждой строке, которое становится новым значением элемента.

временная сложность: O(n⋅m)
Краткое объяснение: Гравитационная сортировка визуально представляет собой движение бусинок вниз по вертикальным линиям, которое приводит к сортировке числового ряда снизу вверх.Общая временная сложность алгоритма определяется созданием матрицы и проходом по всем её элементам.

4. Поиск Скачками
Определение: Скаковый поиск — улучшенный вариант бинарного поиска, применяемый для заранее отсортированных списков. Вместо деления пополам список делится на блоки фиксированного размера, и производится предварительное сравнение первого элемента блока перед поиском внутри блока.


Объяснение работы: 
1. Делится массив на блоки длины m=n.
step = int(math.sqrt(len(arr)))  # Вычисление оптимального шага
Здесь вычисляется оптимальный шаг прыжков, равный квадратному корню из длины массива (n). Это позволяет минимизировать общее количество сравнений при поиске.
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный
искомому
while arr[min(step, len(arr)) - 1] < x:
    prev = step
    step += int(math.sqrt(len(arr)))
    if prev >= len(arr):
        return None
Этот фрагмент реализован циклом, который продолжает двигаться дальше по массиву скачками фиксированного размера, сравнивая последний элемент текущего блока с искомым числом x. Когда встречается первый элемент, превышающий или равный целевому, переход ко второму этапу.
3. Если найденный элемент больше искомого, выполняется линейный поиск в
предыдущем блоке
while arr[prev] < x:
    prev += 1
    if prev == min(step, len(arr)):
        return None
Если предыдущий блок оказался меньше искомого, алгоритм начинает последовательный просмотр предыдущего блока (линейный поиск), двигаясь слева направо. Проверяя каждый элемент, ищется точное совпадение.


Оценка временной сложности: O(sqrt(N)), где N — длина массива. Благодаря уменьшению количества шагов благодаря прыжкам, мы получаем значительное ускорение по сравнению с простым линейным поиском.
Краткое объяснение: Основой скачка является выбор оптимального шага перемещения по массиву, минимизируя общее количество сравнений.

5. Экспоненциальный поиск (Exponential Search)
Определение: Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.

Принцип работы:
1. Проверяется первый элемент массива.
Первый шаг начинается с проверки первого элемента, и переменная bound изначально устанавливается равной 1:
size = len(arr)
bound = 1
Проверяется условие, что начальный элемент меньше или равен цели:
while bound < size and arr[bound] <= target:
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д.,
пока не будет найден элемент, больше или равный искомому.

При выполнении условия (элемент на границе меньше цели), граница удваивается (bound *= 2) до тех пор, пока не встретится элемент, превосходящий цель:
bound *= 2
После выхода из цикла известны границы отрезка, в котором может находиться искомый элемент:
left = bound // 2
right = min(bound, size-1)
3. На найденном диапазоне выполняется бинарный поиск.
while left <= right:
    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        left = mid + 1
    else:
        right = mid - 1
Если целевой элемент найден, возвращается его позиция, иначе возвращается None.

Временная сложность O(log n)
Объяснение: Эффективен при поиске в очень больших отсортированных массивах с
неизвестным размером или частичным доступом.Экспоненциальный поиск состоит из двух этапов: сначала осуществляется экспоненциальное увеличение границы (O(log n)), затем применяется бинарный поиск на ограниченной области (O(log k), где k — расстояние от начальной точки до искомого элемента). Суммарная временная сложность алгоритма составляет O(log n), где n — длина массива.
