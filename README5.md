
# Алгоритмы. Работа в VS Code с алгоритмами сортировки и поиска

1. Определение:
Сортировка выбора (Selection Sort) — это простой алгоритм сортировки массива элементов путем последовательного выбора минимального элемента среди оставшихся несортированных элементов и помещения его в начало отсортированной части массива.

// Функция quicksort реализует основную логику быстрого сортирования
public class QuickSort {
    
    // Метод sort запускает процесс сортировки всего массива
    public static void sort(int[] array) {
        quickSort(array, 0, array.length - 1); // Передаем весь массив и индексы начала и конца
    }

    // Рекурсивная функция быстрой сортировки
    private static void quickSort(int[] array, int low, int high) {
        if (low >= high) return; // Базовый случай: если индекс начала >= индекса конца, значит подмассив пуст или состоит из одного элемента
        
        // Опорный элемент выбирается случайно, чтобы избежать худшего случая O(n^2)
        int pivotIndex = partition(array, low, high);
        
        // Сортируем левую половину относительно выбранного опорного элемента
        quickSort(array, low, pivotIndex - 1);
        
        // Сортируем правую половину
        quickSort(array, pivotIndex + 1, high);
    }

    // Функция partition размещает опорный элемент на правильную позицию,
    // переставляя остальные элементы вокруг него
    private static int partition(int[] array, int low, int high) {
        // Выбираем последний элемент как опорный
        int pivotValue = array[high];
        
        // Индекс первого элемента большей области
        int i = low - 1;
        
        // Перебираем элементы слева направо
        for (int j = low; j <= high - 1; j++) {
            // Если текущий элемент меньше или равен опорному значению,
            // меняем местами с элементом в левой области
            if (array[j] <= pivotValue) {
                i++;
                swap(array, i, j); // Обмениваем два элемента
            }
        }
        
        // Перемещаем опорный элемент на правильное место
        swap(array, i + 1, high);
        
        // Возвращаем новый индекс опорного элемента
        return i + 1;
    }

    // Вспомогательная функция для обмена двух элементов в массиве
    private static void swap(int[] array, int index1, int index2) {
        int temp = array[index1];     // Сохраняем значение первого элемента
        array[index1] = array[index2]; // Присваиваем первому элементу значение второго
        array[index2] = temp;          // Присваиваем второму элементу сохраненное значение
    }

    // Тестируем работу метода
    public static void main(String[] args) {
        int[] exampleArray = {64, 25, 12, 22, 11};
        System.out.println("Исходный массив:");
        printArray(exampleArray);
        
        sort(exampleArray);           // Запускаем сортировку
        
        System.out.println("\nОтсортированный массив:");
        printArray(exampleArray);     // Выводим отсортированный массив
    }

    // Дополнительный метод для вывода содержимого массива
    private static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
    }
}

Вывод в консоль:
Исходный массив:
64 25 12 22 11 
Отсортированный массив:
11 12 22 25 64


Объяснение работы кода:
1. Выбор опорного элемента: Мы выбрали самый простой способ выбора опорного элемента — это крайний правый элемент текущего подмассива (pivotValue = array[high]). Можно выбирать и другим способом (например, среднее значение или случайный элемент), но это влияет лишь на производительность в особых случаях, а общая логика остаётся той же.
2. Разделение массива: Далее идёт цикл, в ходе которого каждый элемент сравнивается с опорным значением. Все элементы, которые меньше или равны опорному, собираются слева от будущей позиции опорного значения, а большие остаются справа. После завершения цикла опорный элемент ставится на своё финальное место путём обмена с последним "меньшим" элементом (i+1).
3. Рекурсия: Процесс повторяется для обоих получившихся подмассивов (левого и правого), пока длина каждого подмассива не станет равна нулю или единице. Таким образом, рекурсивно выполняется сортировка всего массива.

Временная сложность: Общая временная сложность — O(n log n)
Объяснение временной сложности:Алгоритм QuickSort имеет среднюю временную сложность, поскольку массив рекурсивно делится на примерно равные части. Худшая временная сложность достигает O(N^2), если выбор опорного элемента неудачен и массив плохо сбалансирован.


2. Алгоритм сортировка обменом (пузырьком) (Bubble Sort)
Сортировка пузырьком — алгоритм сортировки, который последовательно проходит по списку элементов, сравнивая соседние элементы и меняя их местами, если они расположены в неправильном порядке. Проход повторяется многократно, пока весь список не станет отсортированным. Каждый проход перемещает наибольший элемент своего участка ближе к концу списка, подобно тому, как пузырек поднимается вверх в воде.

Сортировка обменом (пузырьком) (Bubble Sort) на джава 
import java.util.Arrays;

public class Main {
    // Метод для сортировки массива методом пузырька
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        // Проходим по всем элементам массива
        for (int i = 0; i < n - 1; i++) {
            // Последняя позиция каждого прохода уже на своём месте
            for (int j = 0; j < n - i - 1; j++) {
                // Сравниваем соседние элементы
                if (arr[j] > arr[j + 1]) {
                    // Меняем местами, если они стоят в неправильном порядке
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

    // Основной метод
    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("Исходный массив:");
        System.out.println(Arrays.toString(arr));

        bubbleSort(arr); // Применяем сортировку

        System.out.println("Отсортированный массив:");
        System.out.println(Arrays.toString(arr)); // Выводим отсортированный массив
    }
}

Вывод в консоль:
Исходный массив: 64, 34, 25, 12, 22, 11, 90
Отсортированный массив: 11, 12, 22, 25, 34, 64, 90

Объяснение работы кода: 
- Внешний цикл (`for (int i = 0; i < n - 1; i++)`) проходит по всему массиву, уменьшая область проверки с каждым новым шагом, потому что на каждом полном проходе максимальный элемент гарантированно встаёт на свое правильное место в конце массива.
- Во внутреннем цикле (`for (int j = 0; j < n - i - 1; j++)`) происходит непосредственное сравнение соседних элементов. Если текущий элемент больше следующего, они меняются местами.
- Замена реализуется путём сохранения значения одного элемента во временную переменную (`int temp`), изменения положения обоих элементов и восстановления прежнего значения в новом положении.
- Благодаря такому подходу, большие элементы постепенно перемещаются к концу массива. 

Этот метод эффективен для малых объёмов данных и хорош для демонстрации принципов сортировки, однако для больших массивов применяется редко из-за квадратичной сложности O(N²).


Временная сложность: O(n?)
Объяснение временной сложности: Временная сложность алгоритма сортировки пузырьком составляет O(n^2), так как присутствуют два вложенных цикла: внешний цикл проходит по каждому элементу массива, а внутренний цикл сравнивает и меняет местами соседние элементы.


3.Алгоритм сортировка вставками - это простой алгоритм сортировки, который последовательно проходит по элементам массива, сравнивая каждый новый элемент с предыдущими элементами и помещая его на правильную позицию среди уже отсортированных элементов.

def insertion_sort(arr):
    # Проходим по всем элементам массива, начиная со второго
    for i in range(1, len(arr)):
        key = arr[i]              # Текущий элемент, который нужно вставить
        j = i - 1                 # Индекс предыдущего элемента

        # Перемещаем элементы arr[0..i-1], которые больше key,
        # на одну позицию вперёд
        while j >= 0 and arr[j] > key:
            arr[j+1] = arr[j]
            j -= 1
        
        arr[j+1] = key           # Вставляем key на правильное место


# Функция для печати элементов массива
def print_array(arr):
    for val in arr:
        print(val, end=" ")
    print()

if __name__ == "__main__":
    # Исходный массив
    array = [12, 11, 13, 5, 6]
    
    print("Исходный массив:")
    print_array(array)

    # Сортируем массив методом вставок
    insertion_sort(array)

    print("Отсортированный массив:")
    print_array(array)

Вывод в консоль:
Исходный массив: [12, 11, 13, 5, 6] 
Отсортированный массив: [5, 6, 11, 12, 13]

Объяснение работы кода:Код реализует сортировку вставками для массива `arr`. Алгоритм последовательно проходит по каждому элементу массива, начиная со второго, и вставляет его на правильное место среди ранее отсортированных элементов. Во внешнем цикле (`for i in range(1, len(arr))`) берётся очередной элемент `arr[i]`, обозначаемый переменной `key`. Затем внутренний цикл (`while j >= 0 and arr[j] > key`) сдвигает элементы слева направо, пока не найдёт подходящую позицию для вставки `key`. Это делается путём сравнения значений и последовательного перемещения предыдущих элементов вправо (`arr[j+1] = arr[j]`), постепенно уменьшая индекс `j`. После завершения внутреннего цикла элемент `key` помещается на правильную позицию (`arr[j+1] = key`), обеспечивая порядок среди обработанных элементов.

Временная сложность: O(n²)
Объяснение временной сложности: составляет O(n^2), поскольку внешний цикл выполняется n-1 раз, а внутренний цикл в худшем случае тоже может пройти по всему предыдущему участку массива длиной до n-1. Таким образом, общее количество операций пропорционально квадрату длины массива.

4.Сортировка слиянием (Merge Sort)- это алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно) в определённом порядке.

public class MergeSort {

    public static void main(String[] args) {
        int[] array = {38, 27, 43, 3, 9, 82, 10};
        
        System.out.println("Исходный массив:");
        printArray(array);
        
        sort(array);
        
        System.out.println("\nОтсортированный массив:");
        printArray(array);
    }

    // Основная функция сортировки слиянием
    private static void sort(int[] arr) {
        if (arr.length > 1) {
            // Деление массива на две части
            int mid = arr.length / 2;
            int[] left = new int[mid];
            int[] right = new int[arr.length - mid];
            
            for (int i = 0; i < mid; i++) {
                left[i] = arr[i]; // Левая половина
            }
            
            for (int i = mid; i < arr.length; i++) {
                right[i - mid] = arr[i]; // Правая половина
            }
            
            // Рекурсивно сортируем обе половины
            sort(left); 
            sort(right);
            
            // Слияние отсортированных половинок
            merge(arr, left, right);
        }
    }

    // Процедура слияния двух отсортированных массивов
    private static void merge(int[] arr, int[] left, int[] right) {
        int l = 0;   // Индекс левого массива
        int r = 0;   // Индекс правого массива
        int k = 0;   // Индекс результирующего массива
        
        while (l < left.length && r < right.length) {
            if (left[l] <= right[r]) {
                arr[k++] = left[l++];
            } else {
                arr[k++] = right[r++];
            }
        }
        
        // Добавление оставшихся элементов слева
        while (l < left.length) {
            arr[k++] = left[l++];
        }
        
        // Добавление оставшихся элементов справа
        while (r < right.length) {
            arr[k++] = right[r++];
        }
    }

    // Вспомогательная функция для вывода массива
    private static void printArray(int[] arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}

Вывод в консоль:
Исходный массив:38 27 43 3 9 82 10 
Отсортированный массив:3 9 10 27 38 43 82 

Объяснение работы кода:Алгоритм рекурсивно делит массив на подмассивы, пока их длина не достигнет единицы. Затем отсортированные подмассивы объединяются функцией `merge`. Она выбирает минимальные элементы из подмассивов и формирует единый отсортированный массив.
Временная сложность: O(n log n)
Объяснение временной сложности:Массив делится пополам на каждом уровне рекурсии, следовательно, глубина рекурсии равна log n. На каждом уровне рекурсии функция `merge` обрабатывает все n элементов массива за линейное время O(n). Поскольку существует log n уровней, общая временная сложность составляет O(n log n).

5.Сортировка Шелла (Shell sort) — это алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга.
def shell_sort(arr):
    gap = len(arr) // 2  # Устанавливаем начальный промежуток (gap)
    
    # Продолжаем уменьшать gap, пока он не достигнет нуля
    while gap > 0:
        # Проходим по всему массиву с установленным промежутком
        for i in range(gap, len(arr)):  
            current_value = arr[i]  # Текущий элемент
            position = i            # Его текущая позиция
            
            # Сравниваем текущий элемент с элементами, расположенными на расстоянии gap
            while position >= gap and arr[position-gap] > current_value:
                # Если предшествующий элемент больше, сдвигаем его вперед
                arr[position] = arr[position-gap]
                position -= gap  # Передвигаемся назад на gap позиций
            
            # Когда нашли правильное место, ставим текущий элемент на свою позицию
            arr[position] = current_value
        
        # Уменьшаем gap вдвое для следующей итерации
        gap //= 2
### Пример использования
arr = [64, 34, 25, 12, 22, 11, 90]
shell_sort(arr)
print("Отсортированный массив:", arr)
Вывод в консоль:
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]
Объяснение работы кода: сначала массив делится на группы, каждая группа формируется таким образом, что её элементы находятся на фиксированном расстоянии друг от друга (это расстояние называется "gap"). Затем каждая группа сортируется независимо друг от друга. Постепенно "gap" уменьшается, и на последней стадии происходит обычная сортировка вставками над всем массивом.
Временная сложность: O(n log n)
Объяснение временной сложности: Внешний цикл gap уменьшается вдвое от n/2 до 1, что даёт log?(n) итераций 


6.Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых
алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива
на две части относительно опорного (одна — все элементы, меньшие опорного элемента,
вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.


def quick_sort(arr):
    # Основной метод сортировки
    def _quick_sort(arr, low, high):
        if low < high:
            # Получаем индекс разделения массива
            pi = partition(arr, low, high)
            
            # Рекурсивно сортируем левую и правую части
            _quick_sort(arr, low, pi - 1)
            _quick_sort(arr, pi + 1, high)
    
    # Функция для разбиения массива
    def partition(arr, low, high):
        # Опорный элемент — последний элемент массива
        pivot = arr[high]
        
        # Индексация левого конца
        i = low - 1
        
        for j in range(low, high):
            # Перемещаем элементы, которые меньше опорного
            if arr[j] <= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]
        
        # Меняем местами опорный элемент и следующий за последним малым элементом
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        
        return i + 1
    
    # Запускаем основную процедуру сортировки
    _quick_sort(arr, 0, len(arr) - 1)

# Тестируем алгоритм
if __name__ == "__main__":
    array = [10, 7, 8, 9, 1, 5]
    print("Исходный массив:", array)
    quick_sort(array)
    print("\nОтсортированный массив:", array)


Вывод в консоль:
Исходный массив: [10,7,8,9,1,5]
Отсортированный массив: [1,5,7,8,9,10]
Объяснение работы кода: 
1. Основной принцип:
Алгоритм выбирает опорный элемент (pivot), затем перестраивает массив так, чтобы слева от pivot оказались элементы, меньшие либо равные ему, а справа — большие. После этого процедура рекурсивно применяется к обеим частям массива.
2. Разделение массива (Partition function):
Опорный элемент (pivot) выбирается в конце текущего диапазона массива.
Далее проходит итерация по элементам массива, начиная с первого индекса.
Все элементы, которые меньше или равны pivot, перемещаются левее текущих позиций путём обмена местами.
По завершении цикла, опорный элемент меняется местами с первым элементом, находящимся справа от всех малых значений.
Таким образом, теперь массив разделён на две части относительно pivot.
3. Рекурсия (Recursive sorting):
После каждого шага деления выполняется рекурсивный вызов процедуры сортировки для двух новых интервалов массива:
Левый диапазон: [low, pi - 1]
Правый диапазон: [pi + 1, high]
Этот процесс продолжается до тех пор, пока каждый подмассив не станет содержать всего один элемент (базовый случай рекурсии).
4. Основная логика: Процедура начинается с вызова основной функции quick_sort(), которая запускает весь процесс рекурсивной сортировки.

Временная сложность: O(n log n)
Объяснение временной сложности: В среднем случае массив делится пополам на каждом шаге (log n уровней), и на каждом уровне выполняется O(n) операций


7.Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.

import java.util.Arrays;
class HeapSort {

    // Метод для преобразования двоичного дерева в кучу (heapify)
    public static void heapify(int[] arr, int n, int root) {
        int largest = root;          // Рассматриваемый узел (корень)
        int leftChild = 2 * root + 1;// Левый дочерний узел
        int rightChild = 2 * root + 2;// Правый дочерний узел

        // Если левый ребенок существует и больше корня
        if (leftChild < n && arr[leftChild] > arr[largest])
            largest = leftChild;

        // Если правый ребенок существует и больше самого большого узла
        if (rightChild < n && arr[rightChild] > arr[largest])
            largest = rightChild;

        // Если корень не самый большой, меняем местами и восстанавливаем структуру
        if (largest != root) {
            int temp = arr[root];
            arr[root] = arr[largest];
            arr[largest] = temp;

            // Рекурсивно применяем heapify к новому поддереву
            heapify(arr, n, largest);
        }
    }

    // Основная процедура сортировки кучей
    public static void heapSort(int[] arr) {
        int n = arr.length;

        // Строим max-кучу (перестраиваем дерево в бинарную кучу)
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);

        // Один за другим извлекаем максимальный элемент из кучи
        for (int i = n - 1; i > 0; i--) {
            // Перемещение текущего корневого элемента в конец
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // Вызываем heapify на уменьшенной куче
            heapify(arr, i, 0);
        }
    }

    // Главный метод для тестирования
    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6, 7};
        System.out.println("Исходный массив: " + Arrays.toString(arr));

        heapSort(arr); // Вызываем сортировку

        System.out.println("Отсортированный массив: " + Arrays.toString(arr));
??}
??}
Вывод в консоль:
Исходный массив: [12, 11, 13, 5, 6, 7]
Отсортированный массив: [5, 6, 7, 11, 12, 13]
Объяснение работы кода: Код реализует сортировку кучей (heap sort) на Java для массива arrararr Алгоритм строит max-кучу (где родитель больше детей), затем извлекает максимумы, перемещая их в конец массива.
Временная сложность: O(n log n)
Объяснение временной сложности: выполняется n раз, каждое извлечение требует O(log n) операций для восстановления структуры кучи Итого: O(n) + O(n log n) = O(n log n)
8.Последовательный (линейный) поиск — это простой алгоритм, который поочередно проверяет каждый элемент в наборе данных, пока не будет найден искомый элемент или не будет пройден весь список.
public class LinearSearch {

    // Метод для выполнения линейного поиска
    public static int linearSearch(int[] arr, int target) {
        // Просматриваем каждый элемент массива по порядку
        for (int i = 0; i < arr.length; i++) {
            // Если текущий элемент совпадает с искомым значением
            if (arr[i] == target) {
                return i; // Возвращаем индекс найденного элемента
            }
        }
        return -1; // Если элемент не найден, возвращаем -1
    }

    // Тестовый метод для демонстрации работы поиска
    public static void main(String[] args) {
        int[] data = {3, 7, 1, 9, 5};
        int searchElement = 9;
        
        // Вызываем функцию поиска
        int result = linearSearch(data, searchElement);
        
        // Вывод результата
        if(result != -1) {
            System.out.println("Элемент найден на индексе: " + result);
        } else {
            System.out.println("Элемент не найден");
        }
    }
}
Вывод в консоль:
Элемент найден на индексе: 3
Объяснение работы кода: Цикл for проходит по всем элементам массива последовательно, проверяя каждый элемент на совпадение с искомым значением. Условие if:Если текущий элемент массива совпадает с искомым значением, возвращается индекс этого элемента. Возврат результата:Если элемент найден, возвращает его индекс. Если элемент не найден, возвращает -1. Метод main:Демонстрирует использование метода линейного поиска. Создается массив данных. Осуществляется поиск конкретного элемента
Временная сложность: O(n)
Объяснение временной сложности: Алгоритм последовательно проверяет каждый элемент массива (цикл for от 0 до n-1). Проходит все n элементов, делая n сравнений. Это стандартный анализ линейного поиска.
9.Бинарный поиск (Binary Search) — это алгоритм для поиска элемента в отсортированном массиве.

def binary_search(arr, x):
    """
    Бинарный поиск числа x в отсортированном массиве arr.
    Возвращает индекс числа, если оно найдено, иначе -1.
    """
    low = 0                     # Нижняя граница диапазона поиска
    high = len(arr) - 1         # Верхняя граница диапазона поиска
    
    while low <= high:          # Пока границы не пересеклись
        mid = (low + high) // 2 # Вычисляем средний индекс
        
        # Проверяем, какой участок продолжать искать
        if arr[mid] < x:        # Если средний элемент меньше искомого
            low = mid + 1       # Искать в правом диапазоне
        elif arr[mid] > x:      # Если средний элемент больше искомого
            high = mid - 1      # Искать в левом диапазоне
        else:                   # Средний элемент равен искомому
            return mid          # Возвратим индекс среднего элемента
    
    return -1                   # Если элемент не найден, вернуть -1
# Пример использования
sorted_array = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
search_element = 11

result = binary_search(sorted_array, search_element)
if result != -1:
    print(f"Элемент {search_element} найден на индексе {result}.")else:
    print(f"Элемент {search_element} не найден.")
Вывод в консоль:
Элемент 11 найден на индексе 4
Объяснение работы кода: Алгоритм делит диапазон пополам, сравнивает средний элемент с искомым и сужает поиск. 
Временная сложность: O(log n)
Объяснение временной сложности: Алгоритм на каждом шаге делит диапазон поиска пополам (low и high сужаются), что требует ~log?(n) итераций цикла (для n элементов). Каждая итерация — O(1) (сравнения и арифметика). Итого: O(log n)

10.Интерполирующий поиск  — это алгоритм поиска значения в упорядоченном массиве чисел, который работает быстрее бинарного поиска при равномерном распределении данных.

#include <iostream>
using namespace std;
// Интерполирующий поиск в отсортированном массивеint interpolationSearch(int arr[], int n, int x) {
    int low = 0;              // Нижний индекс
    int high = n - 1;         // Верхний индекс

    // Пока нижний индекс меньше верхнего и искомое значение лежит в пределах крайних элементов
    while ((low <= high) && (x >= arr[low]) && (x <= arr[high])) {
        // Если массив содержит одинаковые элементы, проверить крайние индексы
        if (arr[low] == arr[high]) {
            if (arr[low] == x) return low;
            return -1;
        }

        // Формула интерполяционного поиска
        int pos = low + (((double)(high - low) /
                         (arr[high] - arr[low])) *
                        (x - arr[low]));

        // Проверка трех возможных случаев
        if (arr[pos] == x) {   // Значение найдено
            return pos;
        }
        if (arr[pos] < x) {    // Значение больше, смещаемся вправо
            low = pos + 1;
        } else {               // Значение меньше, смещаемся влево
            high = pos - 1;
        }
    }

    return -1;                // Если элемент не найден}
// Основная программаint main() {
    int sortedArr[] = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47};
    int n = sizeof(sortedArr) / sizeof(sortedArr[0]);
    int elementToFind = 18;

    int index = interpolationSearch(sortedArr, n, elementToFind);

    if (index != -1) {
        cout << "Элемент " << elementToFind << " найден на индексе " << index << "." << endl;
    } else {
        cout << "Элемент " << elementToFind << " не найден." << endl;
    }

??return 0;
??}
Вывод в консоль:
Элемент 18 найден на индексе 4.
Объяснение работы кода: Похож на бинарный поиск, но вместо деления пополам, предполагает позицию элемента на основе его значения и значений на границах, предполагая равномерное распределение.
Временная сложность: O(log log n)
Объяснение временной сложности: Интерполяционный поиск использует формулу для оценки позиции элемента на основе его значения (предполагая равномерное распределение), что делает его быстрее бинарного поиска (O(log n)) в идеальных условиях — диапазон сужается экспоненциально быстрее.

11.Поиск методом Фибоначчи  — это итеративный алгоритм для поиска экстремума (минимума или максимума) унимодальной функции на заданном интервале, а также метод поиска нужного значения в отсортированном массиве.

def fibonacci_search(arr, x):
    """Алгоритм поиска Фибоначчи"""
    # Первые числа ряда Фибоначчи
    fib_m_minus_2 = 0  # F(m-2)
    fib_m_minus_1 = 1  # F(m-1)
    fib_M = fib_m_minus_1 + fib_m_minus_2  # F(m)

    # Ищем минимальное число Фибоначчи, большее или равное длине массива
    while fib_M < len(arr):
        fib_m_minus_2 = fib_m_minus_1
        fib_m_minus_1 = fib_M
        fib_M = fib_m_minus_1 + fib_m_minus_2

    offset = -1  # смещение, показывающее начало отрезка поиска

    # Повторяем, пока отрезок поиска не станет пустым
    while fib_M > 1:
        # Определяем индекс для проверки
        i = min(offset + fib_m_minus_2, len(arr)-1)

        # Три возможных сценария:
        if arr[i] < x:  # Если искомое больше, сужаем область поиска вправо
            fib_M = fib_m_minus_1
            fib_m_minus_1 = fib_m_minus_2
            fib_m_minus_2 = fib_M - fib_m_minus_1
            offset = i
        elif arr[i] > x:  # Если искомое меньше, сужаем область поиска влево
            fib_M = fib_m_minus_2
            fib_m_minus_1 = fib_m_minus_1 - fib_m_minus_2
            fib_m_minus_2 = fib_M - fib_m_minus_1
        else:  # Совпадение, элемент найден
            return i

    # Если остался единственный элемент для проверки
    if fib_m_minus_1 and arr[offset+1] == x:
        return offset + 1

    # Если ничего не найдено
    return -1
# Тестируем функцию
data = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
element_to_find = 85

index = fibonacci_search(data, element_to_find)
if index != -1:
    print(f"Элемент {element_to_find} найден на индексе {index}")else:
    print(f"Элемент {element_to_find} не найден")
Вывод в консоль:
Элемент 85 найден на индексе 8
Объяснение работы кода: Использует числа Фибоначчи для определения точек разбиения массива, аналогично бинарному поиску (деление на части), но с разными пропорциями.
Временная сложность: O(log n)
Объяснение временной сложности: Количество чисел Фибоначчи до n примерно равно log n. Каждая итерация цикла while уменьшает размер области поиска, используя меньшие числа Фибоначчи, что приводит к O(log n) итераций.
