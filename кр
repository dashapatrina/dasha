1. Блочная (или корзинная) сортировка (Bucket Sort) — это метод сортировки, при котором элементы исходного массива распределяются по различным контейнерам («корзинам»), каждая из которых потом индивидуально сортируется и объединяется в общий отсортированный список.


Применение на питоне:
def bucket_sort(arr):
    if len(arr) == 0:
        return arr

    # Шаг 1: Определение минимального и максимального значения в массиве
    min_val = min(arr)
    max_val = max(arr)
    
    # Количество корзин определяется числом уникальных возможных интервалов
    num_buckets = len(arr)
    buckets = [[] for _ in range(num_buckets)]

    # Шаг 2: Размещение элементов в соответствующие корзины
    for val in arr:
        index = int((val - min_val) / (max_val - min_val + 1) * (num_buckets - 1))
        buckets[index].append(val)

    # Шаг 3: Отсортировать содержимое каждой корзины (используем встроенную сортировку Python)
    sorted_arr = []
    for bucket in buckets:
        sorted_bucket = sorted(bucket)
        sorted_arr.extend(sorted_bucket)

    return sorted_arr


# Тестирование алгоритма
if __name__ == "__main__":
    input_array = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
    print("Исходный массив:", input_array)
    result = bucket_sort(input_array)
    print("Отсортированный массив:", result)


Вывод в консоль:
Исходный массив: [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
Отсортированный массив: [0.1234, 0.3434, 0.565, 0.656, 0.665, 0.897]

Объяснения работы кода:
1.Определяется количество корзин (например, по диапазону значений элементов):

min_val = min(arr)
max_val = max(arr)
num_buckets = len(arr)
buckets = [[] for _ in range(num_buckets)]
Минимальное и максимальное значения используются для равномерного распределения элементов по корзинам. Число корзин принимается равным длине массива.

2.Каждый элемент помещается в корзину согласно функции распределения:
for val in arr:
    index = int((val - min_val) / (max_val - min_val + 1) * (num_buckets - 1))
    buckets[index].append(val)
Каждое значение сопоставляется определённой корзине на основании формулы распределения. Эта формула равномерно распределяет элементы по корзинам исходя из их относительного положения в диапазоне значений.

3.Содержимое каждой корзины сортируется индивидуально:
sorted_arr = []
for bucket in buckets:
    sorted_bucket = sorted(bucket)
    sorted_arr.extend(sorted_bucket)
Индивидуально каждая корзина сортируется встроенной функцией сортировки Python. Так как распределение элементов достаточно однородно, эта процедура быстрая и эффективная.

4.Корзины соединяются в порядке увеличения диапазона:
Последовательное объединение отсортированных корзин формирует окончательно отсортированный массив.

Таким образом, алгоритм сначала разделяет элементы на группы, а затем быстро собирает их вместе, позволяя эффективно сортировать даже большие наборы данных.

Оценка временной сложности: O(N + k), где N — длина исходного массива, а k — количество корзин. Если распределение достаточно равномерное, то средняя сложность приближается к линейному порядку.
Объяснение временной сложности: Основная идея заключается в распределении элементов по различным контейнерам («корзинам»), что снижает нагрузку на общую операцию сортировки, особенно если элементам удается разделить массив на небольшие части с близкими значениями.

2. Блинная Сортировка
Определение: Идея состоит в том, чтобы каждый раз находить самый большой несортированный элемент и перевернуть его вверх стопки, а затем перевернуть всю верхнюю часть стопки таким образом, чтобы этот элемент оказался внизу.

def flip(arr, i):
    start = 0    while start < i:
        arr[start], arr[i] = arr[i], arr[start]
        start += 1
        i -= 1def pancake_sort(arr):
    curr_size = len(arr)
    while curr_size > 1:
        max_idx = arr.index(max(arr[:curr_size]))
        if max_idx != curr_size - 1:
            flip(arr, max_idx)
            flip(arr, curr_size - 1)
        curr_size -= 1
    return arr
# Тестирование
arr = [3, 6, 2, 4, 5]
sorted_arr = pancake_sort(arr)
print("Отсортированный массив:", sorted_arr)

Вывод в консоль:
Исходный массив:[3, 6, 2, 4, 5]
Отсортированный массив:[2, 3, 4, 5, 6]

Объяснение работы: 
1. Найти максимальный элемент в неотсортированной части массива.
max_idx = arr.index(max(arr[:curr_size]))
Максимальный элемент определяется путём нахождения индекса максимального значения в ещё не отсортированном фрагменте массива (arr[:curr_size]).

2.Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот элемент оказался первым.
flip(arr, max_idx)
Подмассив переворачивается с помощью вспомогательной функции flip(), перемещая максимальный элемент на первое место в текущем несортированном участке.

3.Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце.
flip(arr, curr_size - 1)
Весь текущий участок массива (до последнего неотсортированного элемента) переворачивается второй раз, отправляя максимальный элемент в конец массива.

4.Повторить процесс для оставшейся неотсортированной части массива.
curr_size -= 1
Размер обрабатываемой части уменьшается на единицу, и шаги повторяются заново, пока вся остальная часть массива не окажется отсортирована.

временная сложность: О(N²) 
Краткое объяснение: каждая итерация требует нахождения максимального элемента и двух операций переворота, каждая из которых выполняется за линейное время относительно размера текущего слоя.

3.Сортировка бусинами (Гравитационная)

Определение: Гравитационная сортировка — это визуализированный способ сортировки чисел, имитирующий гравитационное воздействие на бусы, подвешенные вертикально на нитях разной длины. Суть метода в том, что короткие нити будут подниматься быстрее длинных, что обеспечивает упорядочение.

def bead_sort(arr):
    rows = [[True]num + [False](max(arr)-num) for num in arr]
    transposed = list(map(list, zip(*rows)))
    columns_sorted = [[any(row) for row in col] for col in transposed]
    sorted_rows = list(map(list, zip(*columns_sorted)))
    return [sum(row) for row in sorted_rows]
# Тестирование
arr = [5, 3, 1, 7]
sorted_arr = bead_sort(arr)
print("Отсортированный массив:", sorted_arr)

Вывод в консоль:
Исходный массив: [5,3,1,7]
Отсортированный массив: [1,3,5,7]
​
Объяснение работы кода:
1. Каждый элемент массива представляется в виде горизонтального ряда бусин, количество которых соответствует его значению.
rows = [[True]*num + [False]*(max(arr)-num) for num in arr]
Здесь каждому числу из исходного массива присваиваются "бусины" (представленные как `True`), количество которых равно самому числу, а остальные места заполнены пустотой (`False`).

2. Бусины располагаются на «стержнях».
transposed = list(map(list, zip(*rows)))
Матрица поворачивается на бок, создавая представление вертикальных стержней (столбцов), на которых расположены бусины.

3. Под действием «гравитации» бусины падают вниз.
columns_sorted = [[any(row) for row in col] for col in transposed]
Каждая колонка проверяется на наличие хотя бы одной `True` («бусины») сверху вниз. Это аналогично тому, как бусины сползают вниз под действием силы тяжести.

4. После оседания бусин строки считываются сверху вниз — получается отсортированный массив.
sorted_rows = list(map(list, zip(*columns_sorted)))
return [sum(row) for row in sorted_rows]
Строки возвращаются обратно в правильное положение, и подсчитывается количество `True` в каждой строке, которое становится новым значением элемента.

временная сложность: O(n⋅m)
Краткое объяснение: Гравитационная сортировка визуально представляет собой движение бусинок вниз по вертикальным линиям, которое приводит к сортировке числового ряда снизу вверх.Общая временная сложность алгоритма определяется созданием матрицы и проходом по всем её элементам.

4. Поиск Скачками
Определение: Скаковый поиск — улучшенный вариант бинарного поиска, применяемый для заранее отсортированных списков. Вместо деления пополам список делится на блоки фиксированного размера, и производится предварительное сравнение первого элемента блока перед поиском внутри блока.

Пример кода (Python):
import math
def jump_search(arr, x):
    step = int(math.sqrt(len(arr)))# Размер шага
    prev = 0
    while arr[min(step, len(arr))-1] < x:
        prev = step
        step += int(math.sqrt(len(arr)))
        if prev >= len(arr):
            return None
    # Обычный линейный поиск в пределах найденного блока
    while arr[prev] < x:
        prev += 1
        if prev == min(step, len(arr)):
            return None
    if arr[prev] == x:
        return prev
    else:
        return None
# Тестирование
arr = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
search_value = 55
result = jump_search(arr, search_value)
if result is not None:
    print(f"Значение {search_value} найдено на индексе {result}")
else:
    print(f"{search_value} не найдено")

Вывод в консоль:
Исходный массив: [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
Отсортированный массив:[0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]

Объяснение работы: 
1. Делится массив на блоки длины m=n.
step = int(math.sqrt(len(arr)))  # Вычисление оптимального шага
Здесь вычисляется оптимальный шаг прыжков, равный квадратному корню из длины массива (n). Это позволяет минимизировать общее количество сравнений при поиске.
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный
искомому
while arr[min(step, len(arr)) - 1] < x:
    prev = step
    step += int(math.sqrt(len(arr)))
    if prev >= len(arr):
        return None
Этот фрагмент реализован циклом, который продолжает двигаться дальше по массиву скачками фиксированного размера, сравнивая последний элемент текущего блока с искомым числом x. Когда встречается первый элемент, превышающий или равный целевому, переход ко второму этапу.
3. Если найденный элемент больше искомого, выполняется линейный поиск в
предыдущем блоке
while arr[prev] < x:
    prev += 1
    if prev == min(step, len(arr)):
        return None
Если предыдущий блок оказался меньше искомого, алгоритм начинает последовательный просмотр предыдущего блока (линейный поиск), двигаясь слева направо. Проверяя каждый элемент, ищется точное совпадение.


Оценка временной сложности: O(sqrt(N)), где N — длина массива. Благодаря уменьшению количества шагов благодаря прыжкам, мы получаем значительное ускорение по сравнению с простым линейным поиском.
Краткое объяснение: Основой скачка является выбор оптимального шага перемещения по массиву, минимизируя общее количество сравнений.

5. Экспоненциальный поиск (Exponential Search)
Определение: Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.

def exponential_search(arr, target):
    size = len(arr)
    bound = 1
    while bound < size and arr[bound] <= target:
        bound *= 2
    
    left = bound // 2
    right = min(bound, size-1)
    
    # Применяем бинарный поиск в диапазоне [left, right]
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return None

# Тестирование
arr = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
target = 55
index = exponential_search(arr, target)
if index is not None:
    print(f"Искомое значение {target} находится на индексе {index}.")
else:
    print(f"Искомое значение {target} не найдено.")

Вывод в консоль:
Исходный массив:
Отсортированный массив:


Принцип работы:
1. Проверяется первый элемент массива.
Первый шаг начинается с проверки первого элемента, и переменная bound изначально устанавливается равной 1:
size = len(arr)
bound = 1
Проверяется условие, что начальный элемент меньше или равен цели:
while bound < size and arr[bound] <= target:
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д.,
пока не будет найден элемент, больше или равный искомому.

При выполнении условия (элемент на границе меньше цели), граница удваивается (bound *= 2) до тех пор, пока не встретится элемент, превосходящий цель:
bound *= 2
После выхода из цикла известны границы отрезка, в котором может находиться искомый элемент:
left = bound // 2
right = min(bound, size-1)
3. На найденном диапазоне выполняется бинарный поиск.
while left <= right:
    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        left = mid + 1
    else:
        right = mid - 1
Если целевой элемент найден, возвращается его позиция, иначе возвращается None.

Временная сложность O(log n)
Объяснение: Эффективен при поиске в очень больших отсортированных массивах с
неизвестным размером или частичным доступом.Экспоненциальный поиск состоит из двух этапов: сначала осуществляется экспоненциальное увеличение границы (O(log n)), затем применяется бинарный поиск на ограниченной области (O(log k), где k — расстояние от начальной точки до искомого элемента). Суммарная временная сложность алгоритма составляет O(log n), где n — длина массива.
